Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії










ЗВІТ
до практичного завдання № 1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду Airbnb JavaScript Style Guide»










Виконав
ст. гр. ПЗПІ-23-8
Худієнко Микита


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2025
1 ІСТОРІЯ ЗМІН


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	09.10.2025
	0.1
	Створено розділ «Завдання»
	2
	15.03.2025
	0.2
	Створено розділ «Опис Виконаної роботи», «Висновки», «Використані джерела»


	3
	19.03.2025
	0.3
	Створено розділ «Додаток А», «Додаток Б»
	



________________


2 ЗАВДАННЯ


1. Вступ: Важливість правил оформлення коду
2. Структура коду
3. Форматування коду
4. Іменування (іменування змінних, функцій, класів)
5. Коментарі
6. Документування коду
7. Огляд специфічних конвенцій для JavaScript
8. Кодування на основі тестування (Test-Driven Development)
9. Інструменти та автоматизація для підтримки якості коду
10. Приклади оформлення коду: аналіз та обговорення














________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ: Важливість правил оформлення коду


Правила оформлення коду — це інструмент, який робить роботу команди передбачуваною, швидшою і менш ризиковою. Коли всі члени команди дотримуються єдиних правил оформлення коду, він стає зрозумілим незалежно від того, хто його написав. Стандартизація коду дозволяє одразу зосередитися на логіці й архітектурі, замість того щоб думати: “як тут написано?”. Єдина форма подачі коду сприяє швидшому онбордингу нових членів команди, пришвидшує код-рев’ю і робить історію змін (git та merge-conflict) більш читабельною.
Дотримання стилю кодування надає такі переваги:
* читабельність. Коли код написаний за єдиними правилами, ви миттєво розумієте структуру, логіку, призначення кожного блоку;
* підтримуваність. Уявіть, що через рік вам потрібно додати нову функцію або виправити баг у проєкті. Якщо код написаний хаотично, ви витратите години просто на те, щоб зрозуміти, що відбувається. А якщо код оформлений за правилами, то ви швидко орієнтуєтеся, вносите зміни — і йдете далі;
* мінімізація помилок. Багато правил Airbnb Style Guide створено не просто “для краси” — вони допомагають уникати типових помилок. Наприклад, правило завжди використовувати const або let замість var запобігає проблемам зі скоупом змінних.
        Приклад дотримання правила const/let замість var:


  1 // Погано
  2 var a = 1;
  3 var count = 1;
  4 if (true) {
  5   count += 1;
  6 }
  7 // Добре
  8 const a = 1;
  9 let count = 1;
 10 if (true) {
 11   count += 1;
 12 }


3.2 Структура коду


Золоте правило від Airbnb: один файл повинен експортувати одну основну сутність. Якщо у вас є компонент Button, він має бути у файлі Button.js, а не в UIComponents.js разом із десятком інших елементів.
Чому? Тому що, коли з часом потрібно буде щось змінити в кнопці, ви точно знатимете, куди звернутися. 
Airbnb наголошує на принципі Single Responsibility — кожен модуль, клас і функція повинні виконувати щось одне, але робити це добре. 
Розмір модуля має бути меншим за 200–300 рядків — такі файли легше читати й тестувати.
Також для структурування використовують коментарі — це своєрідні “заголовки” в коді. Вони допомагають візуально розділити логічні блоки, зробити код читабельнішим і зручнішим для навігації.


3.3 Форматування коду


Форматування — це набір візуальних правил, які роблять код однорідним і читабельним, незалежно від автора.
Airbnb рекомендує чітке правило для відступів: 2 пробіли для одного рівня. Це забезпечує однаковість у всьому проєкті та допомагає уникати «сходинок» у коді.
Основні принципи відступів:
* ставте один пробіл перед відкривною фігурною дужкою {;
* ставте один пробіл перед круглими дужками в умовах (if, while тощо;.
* не ставте пробілів між іменем функції та її аргументами;
* розділяйте оператори пробілами, щоб покращити візуальне сприйняття.

Щодо довжини рядків — намагайтеся не перевищувати 100 символів.
Для фігурних дужок використовується стиль Kernighan & Ritchie, у якому фігурна дужка відкривається на тій самій лінії, що й конструкція. Як зазначалося раніше, рекомендовано ставити один пробіл перед відкривною дужкою блоку та не ставити пробілів усередині круглих або квадратних дужок.
Також діють правила щодо пробілів усередині фігурних дужок {}:
   * додавайте пробіли для об’єктних літералів або імпорту;
   * не перевантажуйте блоки порожніми рядками.


        Приклад погано та добре форматованого коду:


  1 // Добре
  2 function createUser(name, age) {
  3   const user = {
  4     name,
  5     age,
  6     createdAt: Date.now(),
  7   };
  8
  9   if (user.age >= 18) {
 10     enableAdultFeatures(user);
 11   }
 12
 13   return user;
 14 }
 15 // Погано
 16 function createUser ( name,age )
 17 {
 18 const user={name,age,createdAt: Date.now()};
 19 if (user.age>=18)
 20 {
 21 enableAdultFeatures( user );
 22 }
 23 return user;
 24 }


3.4 Іменування (іменування змінних, функцій, класів)


Добре підібране ім’я економить час, знижує кількість помилок і робить код одразу читабельним.
Для іменування можна виділити основні правила:
   * використовуйте UPPER_CASE — для змінних, що не змінюються під час виконання програми;
   * уникайте імен з однієї літери. Нехай ваші імена будуть описовими;
   * використовуйте camelCase, коли називаєте змінні, об’єкти, функції;
   * використовуйте PascalCase лише тоді, коли називаєте класи;
   * скорочення та абревіатури: або всі великі (HTTP_RESPONSE), або всі маленькі (htmlParser).

При виборі імені спирайтеся на такі принципи:
      * зрозумілість — ім’я повинно відображати суть (що робить змінна чи функція);
      * лаконічність — не надто довге, але достатньо інформативне;
      * унікальність — імена мають бути унікальними в межах області видимості, щоб уникати неоднозначностей у коді;
      * уникайте скорочень без потреби;
      * використовуйте дієслова для назв функцій.

Також уникайте «магічних» значень — це числа або рядки, вставлені прямо в код без пояснення. Краще винести їх в іменовані константи. Для параметрів — використовуйте змістовні назви.


Приклад погано та добре названих змінних, класів, функцій:




    1 // Добре
  2 const DEFAULT_TIMEOUT_SECONDS = 30;
  3 const SCORE_MULTIPLIER = 2.2;
  4
  5 const userName = "Olena";
  6 function calculateUserScore(user) {
  7   return user.posts.length * SCORE_MULTIPLIER;
  8 }
  9
 10 class UserManager {}
 11
 12 // Погано
 13 const pi = 3.14159;
 14
 15 const d = 3;
 16
 17 function calcUsr(u) {
 18   return u.s.length;
 19 }
 20
 21 class usermanager {}


3.5 Коментарі


Коментарі — це допоміжний інструмент: вони пояснюють чому код такий, а не що він робить (це має бути видно із самого коду). Коментувати слід обдумано — краще один доречний коментар, ніж сотня зайвих.
Коли коментар потрібен:
         * щоб пояснити рішення або мотив (чому обрано саме таке рішення, а не інше);
         * щоб описати неочевидні побічні ефекти або зовнішні залежності (таймінги, кешування, обмеження API);
         * використовувати // TODO: — для позначення місць, де потрібно реалізувати вирішення проблеми;
         * використовувати // FIXME: — для опису наявної проблеми, яку треба виправити.

Де ставити коментарі:
            * використовувати // для коментарів в один рядок;
            * розміщувати однорядковий коментар на новому рядку безпосередньо над елементом, до якого він належить;
            * додавати порожній рядок перед коментарем, якщо це не перший рядок блоку.

Як уникати надлишкових коментарів:
               * писати самодокументований код — зрозумілі імена змінних та функцій зменшують потребу в коментарях;
               * оновлювати коментарі разом із кодом — застарілий коментар гірший за його відсутність;
               * уникати тривіальних коментарів, які лише повторюють очевидне.

Приклад погано та добре коментованого коду:


  1 // Добре
  2 // Встановлюємо таймаут 5 с, бо зовнішнє API часто зависає під час піків.
  3 async function fetchData() {
  4   return await fetchWithTimeout(url, 5000);
  5 }
  6 // Регекс дозволяє + в локальній частині email
  7 const emailRegex = /^[\w.+-]+@[\w-]+\.[\w.-]+$/;
  8 // TODO: замінити тимчасовий логін на OAuth2
  9 console.log("debug user:", userId);
 10
 11 // Погано
 12 // Повертає користувача за id
 13 async function getUserById(id) {}
 14 // Регекс для email
 15 const emailRegex = /^[\w.+-]+@[\w-]+\.[\w.-]+$/;
 16 // old: saveUserLegacy(data);
 17 // saveUser(data);


3.6 Документування коду


Документування коду потрібне, щоб передати наміри коду: що робить функція, які параметри очікуються, що повертається.
У світі JavaScript стандартом для документування є JSDoc — це система тегів, які вбудовуються у спеціальні багаторядкові коментарі (/** ... */), безпосередньо над сутністю, яку вони описують (функцією, класом, змінною тощо).
Документація коду робить його більш зрозумілим, щоб навіть людина, яка раніше не працювала з ним, могла швидко розібратися, що і як робить конкретна функція, клас чи модуль.


        Приклад документованого модулю та функції:


  1 /**
  2  * @module rectangleArea
  3  * @description В цьому модулі реалізлвана фунція для обчислення площи прямокутника.
  4  *
  5  * @author Mykyta
  6  * @version 1.0.0
  7  * @since 2025-10-13
  8  */
  9
 10 /**
 11  * Обчислює площу прямокутника за заданими шириною та висотою.
 12  *
 13  * @param {number} width - Ширина прямокутника.
 14  * @param {number} height - Висота прямокутника.
 15  * @returns {number} Площа прямокутника.
 16  *
 17  * @example
 18  * const area = getRectangleArea(5, 10);
 19  * console.log(area); // 50
 20  */
 21 function getRectangleArea(width, height) {
 22   return width * height;
 23 }




3.7 Огляд специфічних конвенцій для JavaScript


        Приклад поганого та хорошого коду специфічних конвенцій JavaScript(див. Додаток В).
  
Огляд специфічних конвенцій для JavaScript
                  * використовувати строге порівняння === / !== замість == / !=, щоб уникнути неочікуваного приведення типів;
                  * використовувати літерали (фігурні дужки) для створення нового об’єкта. Не використовувати конструктор new Object() для створення об’єкта;


  1 // погано
  2 const item = new Object();
  3
  4 // добре
  5 const item = {};


                  * використовувати синтаксис літерала для створення масиву;


  1 // погано
  2 const items = new Array();
  3
  4 // добре
  5 const items = [];


                  * використовувати скорочення для методів об’єкта;


    1 // погано
  2 const atom = {
  3   value: 1,
  4
  5   addValue: function (value) {
  6     return atom.value + value;
  7   },
  8 };
  9
 10 // добре
 11 const atom = {
 12   value: 1,
 13
 14   addValue(value) {
 15     return atom.value + value;
 16   },
 17 };


                  * використовувати скорочення для значень властивостей;
                  * віддавати перевагу spread-оператору (...) над Object.assign для поверхневого копіювання об’єктів і масивів;


    1 // погано
  2 const original = { a: 1, b: 2 };
  3 const copy = Object.assign({}, original, { c: 3 });
  4
  5 // добре
  6 const original = { a: 1, b: 2 };
  7 const copy = { ...original, c: 3 };
  8
  9 // погано
 10 const len = items.length;
 11 const itemsCopy = [];
 12 let i;
 13
 14 for (i = 0; i < len; i += 1) {
 15   itemsCopy[i] = items[i];
 16 }
 17
 18 // добре
 19 const itemsCopy = [...items];


                  * використовувати деструктурування об’єкта, коли потрібно отримати кілька властивостей;


  1 // погано
  2 function getFullName(user) {
  3   const firstName = user.firstName;
  4   const lastName = user.lastName;
  5
  6   return `${firstName} ${lastName}`;
  7 }
  8
  9 // добре
 10 function getFullName(user) {
 11   const { firstName, lastName } = user;
 12   return `${firstName} ${lastName}`;
 13 }
 14
 15 // найкраще
 16 function getFullName({ firstName, lastName }) {
 17   return `${firstName} ${lastName}`;
 18 }


                  * використовувати деструктурування масиву;
                  * використовувати деструктурування об’єкта, а не масиву, для кількох повернених значень.

Для перевірки дотримання стилю в проєкті використовувати Prettier і ESLint.
Prettier — автоматичний форматер: уніфікує відступи, перенесення рядків, лапки тощо, щоб уникнути суперечок про формат.
        ESLint — інструмент статичного аналізу коду: виявляє помилки, антипатерни та застосовує правила (наприклад, Airbnb).






3.8 Кодування на основі тестування (Test-Driven Development)


Test-Driven Development – це підхід, коли ми спочатку пишемо тест, а потім код, який цей тест проходить. Звучить дивно, але працює чудово. Ідея проста: якщо ти знаєш, як має працювати твоя функція, чому б не описати це відразу у вигляді тесту?
Цикл TDD складається з трьох кроків:
                     * Red – пишемо тест, який не проходить (бо коду ще немає)
                     * Green – пишемо мінімальний код, щоб тест запрацював
                     * Refactor – покращуємо код, не ламаючи тести
Airbnb Style Guide заохочує писати код, який легко тестувати. Це означає: пиши чисті функції, де це можливо – вони найлегші для тестування.
Організовуй файли логічно: тести зазвичай лежать поруч з кодом (user.js → user.test.js)
Хороші тести мають бути зрозумілими, швидкими та стабільними.
Пиши тести, які читаються як документація
Тестуй поведінку, а не реалізацію. Якщо ти переписав функцію всередині, але вона працює так само – тести не повинні ламатися.
Один тест – одна перевірка. Якщо тест падає, ти маєш одразу розуміти, що саме зламалося.
Для написання тестів в js найпопулярнішим фреймворком є Jest.
Приклад тесту на jest:




  1 const sum = require("./sum");
  2
  3 test("adds 1 + 2 to equal 3", () => {
  4   expect(sum(1, 2)).toBe(3);
  5 });




3.9 Інструменти та автоматизація для підтримки якості коду


Статичний аналіз перевіряє код автоматично, не запускаючи його. Програма дивиться на твій код і шукає проблеми: баги, дублі, складні місця, вразливості безпеки.
Codacy працює безпосередньо з GitHub і GitLab. Він автоматично аналізує кожен pull request і додає коментарі з виявленими проблемами. Codacy показує, які файли мають найбільше проблем та допомагає тримати якість коду під контролем. Налаштовується простіше, ніж інші інструменти, тому добре підходить для швидкого старту.
Автоматизація означає, що перевірки відбуваються самі, без твоєї участі. Це економить час і гарантує, що нічого не пропустиш.
Git Hooks спрацьовують в певні моменти роботи з Git. Коли ти робиш коміт, автоматично запускаються ESLint, Prettier і тести для змінених файлів. Якщо щось не так – коміт не пройде. Це змушує виправляти проблеми відразу, а не накопичувати їх.
Автоматичні перевірки не дають писати код, який порушує правила. ESLint з конфігом Airbnb – це основа. Він перевіряє, чи дотримуєшся ти правил: чи використовуєш const замість let, чи немає console.log у продакшені, чи правильно імпортуєш модулі.


3.10 Приклади оформлення коду: аналіз та обговорення


Хороший та поганий приклад функції отримання даних користувача. Поганий:
  1 var api = "https://api.example.com";
  2
  3 function getuserD(id) {
  4   return fetch(api + "/users/" + id)
  5     .then(function (r) {
  6       return r.json();
  7     })
  8     .then(function (user) {
  9       console.log("User: " + user.name);
 10       return user;
 11     });
 12 }


Проблеми:
                     * використання var замість const/let;
                     * константа не в UPPER_CASE;
                     * конкатенація замість template strings;
                     * відсутні пробіли та відступи;
                     * Promise chains замість async/await;
                     * погані назви змінних (r, id);
                     * вкладені .then() (callback hell);
                     * використання function замість arrow функцій;
                     * відсутня обробка помилок.


Хорошиий приклад:


  1 const API_BASE_URL = "https://api.example.com";
  2
  3 async function getUserData(userId) {
  4   try {
  5     const userResponse = await fetch(`${API_BASE_URL}/users/${userId}`);
  6
  7     if (!userResponse.ok) {
  8       throw new Error(`HTTP помилка! Статус: ${userResponse.status}`);
  9     }
 10
 11     const user = await userResponse.json();
 12
 13     console.log(`Користувач: ${user.name}`);
 14
 15     return user;
 16   } catch (error) {
 17     console.error(`Помилка отримання даних користувача ${userId}:`, error);
 18     throw error;
 19   }
 20 }


Покращення:
                     * const замість var;
                     * template strings замість конкатенації;
                     * правильні відступи (2 пробіли);
                     * async/await замість promise chains;
                     * зрозумілі назви ;
                     * обробка помилок через try/catch.


Чистота коду впливає на швидкість розуміння:
        Поганий приклад: Розробник витрачає більше часу на те, щоб розібратися, що робить функція. Треба враховувати відсутність форматування, вкладені .then(), незрозумілі назви.
Хороший приклад: Розробник розуміє код майже одразу. Назви говорять самі за себе, структура очевидна, правильне форматування.
Поганий код підвищує складність code review, оскільки дивимося на форматування, а не на логіку. Витрачаємо багато часу.






________________


4 ВИСНОВКИ


Airbnb Style Guide забезпечує єдиний підхід до оформлення JavaScript-коду.
Дотримання стилю підвищує читабельність, підтримуваність і якість коду.
Основні принципи: структурованість, логічний поділ, чітке форматування, зрозумілі імена.
Коментарі мають пояснювати чому, а не що; документація JSDoc — стандарт для JS.
Автоматичні інструменти (ESLint, Prettier, Git Hooks) допомагають підтримувати стандарти без ручних перевірок.
Рекомендовано використовувати Prettier і ESLint із конфігом Airbnb у своїх IDE та проектах.




________________




5 ВИКОРИСТАНІ ДЖЕРЕЛА


                     1. ESLint - Pluggable JavaScript Linter. ESLint. URL: https://eslint.org/ (дата звернення: 19.10.2025).
                     2. Getting Started · Jest. Jest · 🃏 Delightful JavaScript Testing. URL: https://jestjs.io/docs/getting-started (дата звернення: 19.10.2025).
                     3. GitHub - airbnb/javascript: JavaScript Style Guide. GitHub. URL: https://github.com/airbnb/javascript (дата звернення: 19.10.2025).
________________


ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/KTTZ8vGlbog
Хронологічний опис відеозапису:
00:00 - 00:13 Привітання 
00:13 - 01:38 Вступ: Важливість правил оформлення коду
01:39 - 02:30 Структура коду
02:30 - 03:37 Форматування коду
03:37 - 04:52 Іменування (іменування змінних, функцій, класів)
04:52 - 06:49 Коментарі
06:49 - 08:23 Документування коду
08:23 - 09:55 Огляд специфічних конвенцій для JavaScript
09:55 - 11:29Кодування на основі тестування (Test-Driven Development)
11:29 - 13:02 Інструменти та автоматизація для підтримки якості коду
13:02 - 13:50 Приклади оформлення коду: аналіз та обговорення
13:50 - 14:25 Висновки
14:25 Використанні джерела




________________


ДОДАТОК Б
Слайди презентації




  

Рисунок Б.1 — Титульна сторінка


  

Рисунок Б.2 — Важливість правил оформлення коду


  

Рисунок Б.3 — Структура коду


  

Рисунок Б.4 — Форматування коду


  

Рисунок Б.5 — Іменування (іменування змінних, функцій, класів)


  

Рисунок Б.6 — Коментарі


  

Рисунок Б.7 — Документування коду


  

Рисунок Б.8 — Конвенції стилю кодування для JavaScript


  

Рисунок Б.9 — Кодування на основі тестування


  

Рисунок Б.10 — Інструменти та автоматизація для підтримки якості коду


  

Рисунок Б.11 — Приклади оформлення коду


  

Рисунок Б.12 — Висновки


  

Рисунок Б.13 — Використані джерела